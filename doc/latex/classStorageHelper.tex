\hypertarget{classStorageHelper}{}\doxysection{Storage\+Helper Class Reference}
\label{classStorageHelper}\index{StorageHelper@{StorageHelper}}


Help functions for \mbox{\hyperlink{classStorage}{Storage}} related things.  




{\ttfamily \#include $<$Storage\+Helper.\+h$>$}

\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static int \mbox{\hyperlink{classStorageHelper_afc816104c52b9e80211fe4b6eaf3a53a}{loop\+Device\+Associate}} (int file\+Fd, std\+::string $\ast$loop\+Dev\+Path)
\begin{DoxyCompactList}\small\item\em Associates a give file descriptor with a loop device. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{classStorageHelper_a83f81a359083913d7f2aeb8113c35837}{open\+Loop\+Device}} (std\+::string $\ast$loop\+Device)
\begin{DoxyCompactList}\small\item\em Attempts to open an available loop device. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classStorageHelper_a183101593a6f2f3c152deea2a4c77224}{attach\+File\+To\+Loop\+Device}} (int loop\+Fd, int file\+Fd)
\begin{DoxyCompactList}\small\item\em Attempts to attach the file to the loop device. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{classStorageHelper_a20be18e76cd2904d36966dae93ff83e7}{attach\+Loop\+Device}} (const std\+::string \&source\+File, std\+::string $\ast$loop\+Device)
\begin{DoxyCompactList}\small\item\em Attaches the given file to an available loop device. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classStorageHelper_a7d85f5f7e2cd5faa35c1433c5b22f954}{create\+File\+If\+Needed}} (const std\+::string \&file\+Path, const size\+\_\+t storage\+Size, const uid\+\_\+t user\+Id, const std\+::string \&file\+System)
\begin{DoxyCompactList}\small\item\em Checks if file exists, if yes return true, if not try to create it. If success return true, if file don\textquotesingle{}t exist and cannot be created return false. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classStorageHelper_a795a1d4143c767fd617e54d52a1e19c9}{clean\+Mount\+Lost\+And\+Found}} (const std\+::string \&mount\+Point, const std\+::string \&log\+Tag)
\begin{DoxyCompactList}\small\item\em Logs and deletes any files found in the lost+found directory of the mount point. \end{DoxyCompactList}\item 
static std\+::string \mbox{\hyperlink{classStorageHelper_ac72452cf3115ac710ccaa79c1054d994}{get\+Loop\+Device}} (const std\+::string \&backing\+File)
\begin{DoxyCompactList}\small\item\em Get the loop device for a given backing file. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classStorageHelper_a38fe0b1516ed493068ddc0fbc85312ef}\label{classStorageHelper_a38fe0b1516ed493068ddc0fbc85312ef}} 
static int {\bfseries get\+Mount\+Options} (const std\+::list$<$ std\+::string $>$ \&mount\+Options)
\item 
static bool \mbox{\hyperlink{classStorageHelper_a08602b5aa0f9567bd591ec3b486f3d12}{rmdir\+Recursive}} (int dir\+Fd, const std\+::string \&path)
\begin{DoxyCompactList}\small\item\em Removes a directory and all it\textquotesingle{}s contents. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classStorageHelper_a77f0b71f475c655a31bbbf0e6771d150}{rmdir\+Contents}} (int dir\+Fd, const std\+::string \&path)
\begin{DoxyCompactList}\small\item\em Removes the contents of a directory but leave the actual directory in place. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classStorageHelper_aa358b8c96d45ea245c4fd2fcd6b9ccbf}{delete\+Recursive}} (int dirfd, int depth)
\begin{DoxyCompactList}\small\item\em Recursive function that deletes everything within the supplied directory (as a descriptor). \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Help functions for \mbox{\hyperlink{classStorage}{Storage}} related things. 

All low level help functions that doesn\textquotesingle{}t rely on current state 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classStorageHelper_a183101593a6f2f3c152deea2a4c77224}\label{classStorageHelper_a183101593a6f2f3c152deea2a4c77224}} 
\index{StorageHelper@{StorageHelper}!attachFileToLoopDevice@{attachFileToLoopDevice}}
\index{attachFileToLoopDevice@{attachFileToLoopDevice}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{attachFileToLoopDevice()}{attachFileToLoopDevice()}}
{\footnotesize\ttfamily bool Storage\+Helper\+::attach\+File\+To\+Loop\+Device (\begin{DoxyParamCaption}\item[{int}]{loop\+Fd,  }\item[{int}]{file\+Fd }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Attempts to attach the file to the loop device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em loop\+Fd} & An open file descriptor to the loop device \\
\hline
\mbox{\texttt{ in}}  & {\em file\+Fd} & An open file descriptor that should be associate with the loop device.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
on success a positive file desccriptor corresponding to a free loop device, -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_a20be18e76cd2904d36966dae93ff83e7}\label{classStorageHelper_a20be18e76cd2904d36966dae93ff83e7}} 
\index{StorageHelper@{StorageHelper}!attachLoopDevice@{attachLoopDevice}}
\index{attachLoopDevice@{attachLoopDevice}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{attachLoopDevice()}{attachLoopDevice()}}
{\footnotesize\ttfamily int Storage\+Helper\+::attach\+Loop\+Device (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{source\+File,  }\item[{std\+::string $\ast$}]{loop\+Device }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Attaches the given file to an available loop device. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em source\+File} & The path to the image file. \\
\hline
\mbox{\texttt{ out}}  & {\em loop\+Device} & The path to the loop device that was attached.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the file descriptor to the loop device if attached, otherwise -\/1. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_a795a1d4143c767fd617e54d52a1e19c9}\label{classStorageHelper_a795a1d4143c767fd617e54d52a1e19c9}} 
\index{StorageHelper@{StorageHelper}!cleanMountLostAndFound@{cleanMountLostAndFound}}
\index{cleanMountLostAndFound@{cleanMountLostAndFound}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{cleanMountLostAndFound()}{cleanMountLostAndFound()}}
{\footnotesize\ttfamily void Storage\+Helper\+::clean\+Mount\+Lost\+And\+Found (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{mount\+Point,  }\item[{const std\+::string \&}]{log\+Tag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Logs and deletes any files found in the lost+found directory of the mount point. 

We should be clearing the lost+found to avoid cruft building up and taking all the space in the loop mount.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mount\+Point} & The absolute path to the mounted device, NOT the the location of the lost+found dir. \\
\hline
\mbox{\texttt{ in}}  & {\em log\+Tag} & If not empty then a log warning message will be printed containing the name of the file that was deleted and referencing the the string in log\+Tag. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classStorageHelper_a7d85f5f7e2cd5faa35c1433c5b22f954}\label{classStorageHelper_a7d85f5f7e2cd5faa35c1433c5b22f954}} 
\index{StorageHelper@{StorageHelper}!createFileIfNeeded@{createFileIfNeeded}}
\index{createFileIfNeeded@{createFileIfNeeded}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{createFileIfNeeded()}{createFileIfNeeded()}}
{\footnotesize\ttfamily bool Storage\+Helper\+::create\+File\+If\+Needed (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file\+Path,  }\item[{const size\+\_\+t}]{storage\+Size,  }\item[{const uid\+\_\+t}]{user\+Id,  }\item[{const std\+::string \&}]{file\+System }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks if file exists, if yes return true, if not try to create it. If success return true, if file don\textquotesingle{}t exist and cannot be created return false. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+Path} & Path to the file that should exist after this function exits \\
\hline
\mbox{\texttt{ in}}  & {\em storage\+Size} & Size of the created image file (in bytes) \\
\hline
\mbox{\texttt{ in}}  & {\em user\+Id} & The expected user id set in the xattr of the image file \\
\hline
\mbox{\texttt{ in}}  & {\em file\+System} & Filesystem of created image file \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classStorageHelper_aa358b8c96d45ea245c4fd2fcd6b9ccbf}\label{classStorageHelper_aa358b8c96d45ea245c4fd2fcd6b9ccbf}} 
\index{StorageHelper@{StorageHelper}!deleteRecursive@{deleteRecursive}}
\index{deleteRecursive@{deleteRecursive}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{deleteRecursive()}{deleteRecursive()}}
{\footnotesize\ttfamily bool Storage\+Helper\+::delete\+Recursive (\begin{DoxyParamCaption}\item[{int}]{dirfd,  }\item[{int}]{avail\+Depth }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Recursive function that deletes everything within the supplied directory (as a descriptor). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dir\+Fd} & If specified the path should be relative to to this directory. \\
\hline
\mbox{\texttt{ in}}  & {\em avail\+Depth} & Maximal depth of recursion\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_ac72452cf3115ac710ccaa79c1054d994}\label{classStorageHelper_ac72452cf3115ac710ccaa79c1054d994}} 
\index{StorageHelper@{StorageHelper}!getLoopDevice@{getLoopDevice}}
\index{getLoopDevice@{getLoopDevice}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{getLoopDevice()}{getLoopDevice()}}
{\footnotesize\ttfamily std\+::string Storage\+Helper\+::get\+Loop\+Device (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{backing\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get the loop device for a given backing file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em backing\+File} & Path of backing file.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
on success a string containing the name of the loop device, empty string on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_afc816104c52b9e80211fe4b6eaf3a53a}\label{classStorageHelper_afc816104c52b9e80211fe4b6eaf3a53a}} 
\index{StorageHelper@{StorageHelper}!loopDeviceAssociate@{loopDeviceAssociate}}
\index{loopDeviceAssociate@{loopDeviceAssociate}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{loopDeviceAssociate()}{loopDeviceAssociate()}}
{\footnotesize\ttfamily int Storage\+Helper\+::loop\+Device\+Associate (\begin{DoxyParamCaption}\item[{int}]{file\+Fd,  }\item[{std\+::string $\ast$}]{loop\+Dev\+Path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Associates a give file descriptor with a loop device. 

First the function attempts to get a free loop device, if that succeeds it attaches the supplied file descriptor to it and returns an fd to the loop device and (optionally) writes the path to the loop device in the {\itshape loop\+Dev\+Path} string.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+Fd} & An open file descriptor to associate with the loop device. \\
\hline
\mbox{\texttt{ out}}  & {\em loop\+Dev\+Path} & If not null, the method will write the path to the loop device dev node into the string\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
on success returns the open file descriptor to the loop device associated with the file, on failure -\/1. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_a83f81a359083913d7f2aeb8113c35837}\label{classStorageHelper_a83f81a359083913d7f2aeb8113c35837}} 
\index{StorageHelper@{StorageHelper}!openLoopDevice@{openLoopDevice}}
\index{openLoopDevice@{openLoopDevice}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{openLoopDevice()}{openLoopDevice()}}
{\footnotesize\ttfamily int Storage\+Helper\+::open\+Loop\+Device (\begin{DoxyParamCaption}\item[{std\+::string $\ast$}]{loop\+Device }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Attempts to open an available loop device. 

WARNING this method requires sudo


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em loop\+Device} & Loop device name\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
on success a positive file descriptor corresponding to a free loop device, -\/1 on error. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_a77f0b71f475c655a31bbbf0e6771d150}\label{classStorageHelper_a77f0b71f475c655a31bbbf0e6771d150}} 
\index{StorageHelper@{StorageHelper}!rmdirContents@{rmdirContents}}
\index{rmdirContents@{rmdirContents}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{rmdirContents()}{rmdirContents()}}
{\footnotesize\ttfamily bool Storage\+Helper\+::rmdir\+Contents (\begin{DoxyParamCaption}\item[{int}]{dir\+Fd,  }\item[{const std\+::string \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Removes the contents of a directory but leave the actual directory in place. 

This is equivalent to the \textquotesingle{}rm -\/rf $<$dir$>$/ $\ast$\textquotesingle{} command.

If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dir\+Fd, if dir\+Fd is not supplied then it\textquotesingle{}s relative to the cwd.

\begin{DoxyWarning}{Warning}
This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dir\+Fd} & If specified the path should be relative to to this directory. \\
\hline
\mbox{\texttt{ in}}  & {\em path} & The path to the directory to create.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure.
\end{DoxyReturn}
This is equivalent to the \textquotesingle{}cd $<$dir$>$; rm -\/rf $\ast$\textquotesingle{} command.

If the pathname given in {\itshape path} is relative, then it is interpreted relative to the directory referred to by the file descriptor {\itshape dir\+Fd}, if {\itshape dir\+Fd} is not supplied then it\textquotesingle{}s relative to the cwd.

\begin{DoxyWarning}{Warning}
This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dir\+Fd} & If specified the path should be relative to to this directory. \\
\hline
\mbox{\texttt{ in}}  & {\em path} & The path to the directory to create.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{classStorageHelper_a08602b5aa0f9567bd591ec3b486f3d12}\label{classStorageHelper_a08602b5aa0f9567bd591ec3b486f3d12}} 
\index{StorageHelper@{StorageHelper}!rmdirRecursive@{rmdirRecursive}}
\index{rmdirRecursive@{rmdirRecursive}!StorageHelper@{StorageHelper}}
\doxysubsubsection{\texorpdfstring{rmdirRecursive()}{rmdirRecursive()}}
{\footnotesize\ttfamily bool Storage\+Helper\+::rmdir\+Recursive (\begin{DoxyParamCaption}\item[{int}]{dir\+Fd,  }\item[{const std\+::string \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Removes a directory and all it\textquotesingle{}s contents. 

This is equivalent to the \textquotesingle{}rm -\/rf $<$dir$>$\textquotesingle{} command.

If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dir\+Fd, if dir\+Fd is not supplied then it\textquotesingle{}s relative to the cwd.

\begin{DoxyWarning}{Warning}
This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dir\+Fd} & If specified the path should be relative to to this directory. \\
\hline
\mbox{\texttt{ in}}  & {\em path} & The path to the directory to create.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure.
\end{DoxyReturn}
This is equivalent to the \textquotesingle{}rm -\/rf\textquotesingle{} command.

If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dir\+Fd, if dir\+Fd is not supplied then it\textquotesingle{}s relative to the cwd.

\begin{DoxyWarning}{Warning}
This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dir\+Fd} & If specified the path should be relative to to this directory. \\
\hline
\mbox{\texttt{ in}}  & {\em path} & The path to the directory to create.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
rdk\+Plugins/\+Storage/source/Storage\+Helper.\+h\item 
rdk\+Plugins/\+Storage/source/Storage\+Helper.\+cpp\end{DoxyCompactItemize}
